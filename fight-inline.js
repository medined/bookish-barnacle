(function(){const HERO_DATA=JSON.parse(document.getElementById('hero-data').textContent);const heroes=[...HERO_DATA].sort((a,b)=>a.name.localeCompare(b.name));const heroMap=new Map(heroes.map(hero=>[hero.name,hero]));const heroASelect=document.getElementById('heroA');const heroBSelect=document.getElementById('heroB');const seedInput=document.getElementById('seedInput');const roundsInput=document.getElementById('roundsInput');const summaryEl=document.getElementById('summary');const logEl=document.getElementById('log');const heroACard=document.getElementById('heroACard');const heroBCard=document.getElementById('heroBCard');populateSelect(heroASelect);populateSelect(heroBSelect);if(heroBSelect.options.length>1){heroBSelect.selectedIndex=1;}renderHeroCards();document.getElementById('fightForm').addEventListener('submit',event=>{event.preventDefault();runFight();});heroASelect.addEventListener('change',renderHeroCards);heroBSelect.addEventListener('change',renderHeroCards);function populateSelect(select){const roles={};heroes.forEach(hero=>{roles[hero.role]=roles[hero.role]||[];roles[hero.role].push(hero);});Object.keys(roles).sort().forEach(role=>{roles[role].sort((a,b)=>a.name.localeCompare(b.name));const group=document.createElement('optgroup');group.label=role;roles[role].forEach(hero=>{const option=document.createElement('option');option.value=hero.name;option.textContent=hero.name;group.appendChild(option);});select.appendChild(group);});}
function renderHeroCards(){renderHeroCard(heroMap.get(heroASelect.value),heroACard,'Hero 1');renderHeroCard(heroMap.get(heroBSelect.value),heroBCard,'Hero 2');}
function renderHeroCard(hero,container,label){if(!hero){container.innerHTML='<p class="muted">Select a hero</p>';return;}const weapon=hero.weapon;const clip=typeof weapon.clipSize==='number'?weapon.clipSize:'∞';container.innerHTML=`<h3>${label}: ${hero.name}<span>${hero.role}</span></h3>
<p>Health: ${hero.health.toFixed(0)} | Armor: ${hero.armor.toFixed(0)}</p>
<p>Weapon: ${weapon.name} (${weapon.description || 'unknown'})</p>
<p>DPS: ${weapon.dpsFiring.toFixed(1)} | Shots/s: ${weapon.shotsPerSecond.toFixed(2)}</p>
<p>Damage/shot: ${weapon.damagePerShot.toFixed(2)} | Clip: ${clip}</p>`;}
function runFight(){const heroA=heroMap.get(heroASelect.value);const heroB=heroMap.get(heroBSelect.value);if(!heroA||!heroB){summaryEl.textContent='Pick two heroes to start.';logEl.innerHTML='';return;}if(heroA.name===heroB.name){summaryEl.textContent='Pick two different heroes to fight.';logEl.innerHTML='';return;}const maxRounds=Math.max(1,Math.min(100,Number(roundsInput.value)||30));const seedValue=seedInput.value.trim();const randomFn=seedValue!==''?mulberry32(Number(seedValue)||0):null;const sim=simulateFight(heroA,heroB,randomFn,maxRounds);renderSummary(heroA,heroB,sim);renderLog(sim.rounds);}function mulberry32(seed){let a=seed>>>0;return function(){a|=0;a=(a+0x6D2B79F5)|0;let t=Math.imul(a^a>>>15,1|a);t=(t+Math.imul(t^t>>>7,61|t))^t;return((t^t>>>14)>>>0)/4294967296;};}
function createFighter(hero){return{hero,health:hero.health,armor:hero.armor,maxHealth:hero.health,maxArmor:hero.armor,weapon:hero.weapon,ammo:typeof hero.weapon.clipSize==='number'?hero.weapon.clipSize:null,reloadTimer:0,tookDamage:false};}
function performAttack(state,rand){if(state.health<=0){return{damage:0,note:'Eliminated'};}if(state.reloadTimer>0){state.reloadTimer=Math.max(0,state.reloadTimer-1);if(state.reloadTimer===0&&typeof state.weapon.clipSize==='number'){state.ammo=state.weapon.clipSize;}return{damage:0,note:'Reloading'};}const shotsPerSecond=state.weapon.shotsPerSecond;const notes=[];let damage=0;if(shotsPerSecond<=0&&state.weapon.dpsFiring>0){damage=state.weapon.dpsFiring;notes.push('sustained DPS');}else{let shotsFired=0;if(typeof state.weapon.clipSize!=='number'){shotsFired=shotsPerSecond;}else{if(state.ammo==null){state.ammo=state.weapon.clipSize;}const available=Math.min(state.ammo,shotsPerSecond);shotsFired=Math.max(0,available);state.ammo-=available;if(state.ammo<=0&&state.weapon.reloadTime>0){state.reloadTimer=state.weapon.reloadTime;state.ammo=0;notes.push('clip empty');}}damage=Math.max(0,shotsFired)*state.weapon.damagePerShot;if(typeof state.weapon.clipSize==='number'){notes.push(`${shotsFired.toFixed(1)} shots`);}}const rng=rand||Math.random;if(state.weapon.critChance>0&&rng()<state.weapon.critChance){damage*=2;notes.push('CRIT');}if(state.hero.role.toLowerCase()==='damage'){damage*=1.05;notes.push('+5% DPS passive');}return{damage,note:notes.length?notes.join(', '):'standard fire'};}
function applyDamage(state,incoming){if(state.health<=0||incoming<=0){state.tookDamage=false;return{taken:0,armorBroken:false};}let armorBroken=false;let effective=incoming;if(state.armor>0){effective*=0.70;const absorbed=Math.min(state.armor,effective);state.armor-=absorbed;state.health-=effective-absorbed;armorBroken=state.armor===0&&absorbed>0;}else if(state.hero.role.toLowerCase()==='tank'){effective*=0.90;state.health-=effective;}else{state.health-=effective;}state.health=Math.max(0,state.health);state.tookDamage=effective>0;return{taken:effective,armorBroken};}
function applySupportRegen(state){if(state.hero.role.toLowerCase()!=='support'){return null;}if(state.tookDamage||state.health<=0){return null;}const missing=state.maxHealth-state.health;if(missing<=0){return null;}const heal=Math.min(15,missing);state.health=Math.min(state.maxHealth,state.health+heal);return heal;}
function simulateFight(heroA,heroB,rand,maxRounds){const fighterA=createFighter(heroA);const fighterB=createFighter(heroB);const randomFn=typeof rand==='function'?rand:null;const rounds=[];let roundNumber=1;while(fighterA.health>0&&fighterB.health>0&&roundNumber<=maxRounds){const attackA=performAttack(fighterA,randomFn);const attackB=performAttack(fighterB,randomFn);const toB=applyDamage(fighterB,attackA.damage);const toA=applyDamage(fighterA,attackB.damage);const regenB=applySupportRegen(fighterB);const regenA=applySupportRegen(fighterA);rounds.push({round:roundNumber,first:{attacker:heroA.name,target:heroB.name,damage:toB.taken,note:attackA.note,targetHealth:fighterB.health,targetArmor:fighterB.armor,armorBroken:toB.armorBroken,regen:regenB},second:{attacker:heroB.name,target:heroA.name,damage:toA.taken,note:attackB.note,targetHealth:fighterA.health,targetArmor:fighterA.armor,armorBroken:toA.armorBroken,regen:regenA}});roundNumber+=1;}let outcome='Stalemate reached — maximum rounds exceeded.';if(fighterA.health>0&&fighterB.health<=0){outcome=`${heroA.name} wins with ${fighterA.health.toFixed(1)} HP remaining.`;}else if(fighterB.health>0&&fighterA.health<=0){outcome=`${heroB.name} wins with ${fighterB.health.toFixed(1)} HP remaining.`;}else if(fighterA.health<=0&&fighterB.health<=0){outcome='Both heroes fall simultaneously — it's a draw!';}else if(roundNumber-1<maxRounds){outcome='Fight interrupted.';}return{rounds,outcome};}
function renderSummary(heroA,heroB,sim){summaryEl.innerHTML=`<p><strong>${heroA.name}</strong> vs <strong>${heroB.name}</strong></p><p>${sim.outcome}</p>`;}
function renderLog(rounds){if(!rounds.length){logEl.innerHTML='<p class="muted">No rounds played.</p>';return;}logEl.innerHTML='';rounds.forEach(entry=>{const card=document.createElement('article');addText(card,'h4',`Round ${entry.round}`);addText(card,'p',formatLine(entry.first));if(entry.first.armorBroken){addText(card,'p',`${entry.first.target}'s armor breaks!`,true);}if(entry.first.regen){addText(card,'p',`${entry.first.target} regains ${entry.first.regen.toFixed(1)} HP from Support passive.`,true);}addText(card,'p',formatLine(entry.second));if(entry.second.armorBroken){addText(card,'p',`${entry.second.target}'s armor breaks!`,true);}if(entry.second.regen){addText(card,'p',`${entry.second.target} regains ${entry.second.regen.toFixed(1)} HP from Support passive.`,true);}logEl.appendChild(card);});}
function addText(parent,tag,text,muted=false){const el=document.createElement(tag);el.textContent=text;if(muted){el.classList.add('muted');}parent.appendChild(el);}
function formatLine(info){return`${info.attacker} deals ${info.damage.toFixed(1)} dmg (${info.note}) → ${info.target} HP ${info.targetHealth.toFixed(1)} / Armor ${info.targetArmor.toFixed(1)}`;}})();